# 2주차 과제: 자바 데이터 타입, 변수 그리고 배열



> # 목표
>
> 자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.
>
> ## 학습할 것
>
> - 프리미티브 타입 종류와 값의 범위 그리고 기본 값
> - 프리미티브 타입과 레퍼런스 타입
> - 리터럴
> - 변수 선언 및 초기화하는 방법
> - 변수의 스코프와 라이프타임
> - 타입 변환, 캐스팅 그리고 타입 프로모션
> - 1차 및 2차 배열 선언하기
> - 타입 추론, var
>
> ## 마감 일시 (한국 시간 기준)
>
> 2020년 11월 23일 오후3시



## 프리미티브 타입 종류와 값의 범위 그리고 기본 값



#### Primitive Type 이란?

기본자료형의 **원시자료형.**

값이 할당될 때, 값 이 그대로 저장되며, **JVM Runtime Data Area** 중 `Stack` 영역에 저장됨.



#### 프리미티브 타입 종류

| 이름|크기|기본 값|값의 범위|비고|
| ------ | ---- | ------- | ------- | ---- |
| byte | 1byte (8bit) | 0 | -128 ~ 127 | 정수형 |
| short | 2byte (16bit) | 0 | -32,768 ~ 32,767 | 정수형 |
| int | 4byte (32bit) | 0 | -2,147,483,648 ~ 2,147,483,647 | 정수형 |
| long | 8byte (64bit) | 0L | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 정수형 |
| float | 4byte (32bit) | 0.0f | 1.4E-45 ~ 3.4028235E38 | 실수형 |
| double | 8byte (64bit) | 0.0d | 4.9E-324 ~ 1.7976931348623157E308 | 실수형 |
| char | 2byte (16bit) | '\u0000' | '\u0000' ~ '\uffff' (부호bit가 없기 때문에, 2^16 의 경우의 수 중, 0 ~ 65535) | 문자형, 유니코드 |
| boolean | 1byte (8bit) | false | false , true | 논리형 |

- 정수형
  범위는 sign bit 가 포함 되기 때문에, 값의 범위는 자료형의 크기(bit 수) 에서 sign bit 를 뺀 경우의 수를 통해 도출 할 수 으며,
  0이라는 값도 표현 범위에 포함 해야 하기 때문에, 양의 범위에서 0을 표현한다.

  ```
  N : 자료형의 크기 - 1 (sign bit)
  수의 표현 가능 갯수 : 2^N
  범위 : -2^N ~ (2^N - 1)
  ```

- 실수형
  부호, 지수(exponent), 가수(mantissa) 를 구분하는 부동 소수점 방식

  - 부호 : 양수/음수 구분 (1비트)

  - 지수 : 수를 근시하기 위해, 가수로 표현시, 이동해야 하는 값

  - 가수 : 소수 이하 표시 (0보다 크고 1보다 작은 값)

    > -314.625 의 IEEE 754 부동소수점 (32비트 단정도) 표현
    >
    > - 부호
    >   음수 이므로 `1`
    >
    > - 가수부
    >
    >   314.625 (절대값)
    >   = 100111010.101 (2진수)
    >
    >   	- 십진수의 소수점 계산은, 2를 곱하여 계산된 수의 정수 부분을 계속 취하는 방식
    >    - 0.625(10)
    >      	- 0.625 * 2 = `1`.25 => 1
    >      	- 0.25 * 2 = `0`.5 => 0
    >      	- 0.5 * 2 = `1`.0 => 1
    >      	- 즉 0.625(10) = 0.101(2)
    >
    >   = 1.00111010101(2) * `2^8`
    >
    >   - 2진수의 소수점을 왼쪽으로 이동하여, 소수점 왼쪽에 1만 남김 (`8번 이동`)
    >
    >     100111010`.`101(2) => 1`.`00111010101(2)
    >
    >   `00111010101` (소수점 부분을 가수부 비트에 앞에서 부터 취함)
    >
    > - 지수부
    >
    >   지수 + bias 의 2진수
    >
    >   = 8 + 127 (float 의 경우) = 135 = `10000111`(2)
    >
    >   - 가수부 계산을 통해 `8` 취함
    >   - bias : 2^(k-1) (k:지수부의 비트수)
    >
    > 
    >
    > 32비트 단정도 (4byte)
    >
    > | 부호 (1bit) | 지수(8bit) | 가수(23bit)               |
    > | ----------- | ---------- | ------------------------- |
    > | 1           | 10000111   | `00111010101`000000000000 |

> 참조
>
> - https://m.blog.naver.com/PostView.nhn?blogId=winzone&logNo=70175202044&proxyReferer=https:%2F%2Fwww.google.com%2F
> - https://codetorial.net/articles/floating_point.html





## 프리미티브 타입과 레퍼런스 타입

### Reference Type

참조 한다는 의미의 자료 형이며, Object 의 주소를 저장한다.

**JVM Runtime Data Area** 중 `heap` 영역에 저장된다. GC 의 관리 대상이 된다.





## 리터럴

소스 코드 내, 변수의 값으로 직접 입력된 값.

### 상수(Constant)

- 변하지 않는 값(데이터)를 의미

- 변하지 않는 `변수`
  참조변수를 상수 처리(final) 한 경우, 레퍼런스 타입의 주소값이 변하지 않는 것. 참조한 Object 의 값은 바뀔 수 있다.

### 리터럴(Literal)

- 데이터 그 자체
- 변수에 넣은 변하지 않은 `데이터`를 의미
- 인스턴스 가 리터럴이 될 수 있을까?
  => immutable class (데이터가 변하지 않도록 설계한 클래스)

> 참조
>
> https://mommoo.tistory.com/14





## 변수 선언 및 초기화하는 방법

### 변수(variable)

데이터를 저장하기 위한 이름을 할당받은 메모리 공간

### 변수의 선언

1. 변수 선언만 하는 경우

   변수를 선언하여, 메모리 공간을 할당 받으나, 값을 지정하지 안기 때문에, 쓰레기 값이 있음.

   사용시 반드시 초기화 한 후에 사용되어야 함

   ```java
   int number;
   ```

2. 변수 선언 및 초기화

   변수 선언과 동시에, 값을 초기화 할 수 있음

   ```java
   int number = 3;
   int count = getCount();
   ```

   ps. 위 경우, 실제 내부적으로는 1 단위의 코드 실행이 아니므로, 멀티 쓰레드에서는 주의 해야하는 고려사항이 있음 (ex. singleton)





## 변수의 스코프와 라이프타임

### 스코프(scope)

변수가 존재할 수 있는 영역(범위). Java 에서 중괄호 {} 를 사용한 범위가 지정됨.

유효 범위의 우선순위 : 지역변수 > 멤버변수

- 멤버 변수 : 클래스 영역에서 선언된 변수
  - 클래스 변수
  - 인스턴스 변수
- 지역 변수 : 메소드나 생성자 내부에 선언된 변수

```java
class Car {
	static String type = "Car"; // 클래스 변수
	int count = 0; // 인스턴스 변수
  
  public void startEngin() {
    boolean checkError; // 지역 변수
  }
}
```



### 라이프타임(lifeTime)

변수의 생명 주기

- 지역 변수 : 블록 영역 내 에서 유지됨
- 클래스 변수 : 클래스 로더에 의해 클래스가 초기화되고 프로그램 종료까지 유지
- 인스턴스 변수 : 인스턴스가 생성되고 메모리에 있는 동안 유지





## 타입 변환, 캐스팅 그리고 타입 프로모션

### 타입 변환

Data Type Conversion

- 자동 타입 변환 (Type Promotion) - 묵시적
  더 큰 자료형의 이동에는 데이터 손실이 없기 때문에 자동 타입 변환이 발생함

  byte >> char >> int >> long >> float >> double

- 강제 타입 변환 (Type Casting) - 명시적
  데이터 타입이 다른 상황에서, 작은 데이터 타입으로 변경 하는 경우, 데이터 손실이 발생할 수 있기 때문에, 자동 타입 변환이 동작하지 않음.
  명시적으로 타입 변환을 지정하는 경우 사용 (캐스팅)

### 캐스팅(casting)

```
작은 크기 타입 = (작은 크기 타입) 큰 크기 타입
```

변환시키려는 데이터 앞에 () 를 사용하여 변환하려는 데이터 타입을 사용





## 1차 및 2차 배열 선언하기

### 배열 선언 방법

```java
int[] array;
int aray[];
```

### 1차 및 2차 .. n차 배열 선언

배열은 동일한 데이터 타입의 집합으로 볼수 있으며, 2차 는 집합의 또한 집합. n 차 배열은 집합 `2^n` 의 개념으로 볼 수 있다.

- 1차 배열

  ```
  {1,2,3,4}
  ```

- 2차 배열

  ```
  {{1,2,3,4},{1,2,3,4}}
  ```

- 3차 배열

  ```
  {{{1,2,3,4},{1,2,3,4}},{{1,2,3,4},{1,2,3,4}}}
  ```

- N차 배열..





## 타입 추론, var

### 타입 추론 (Type Inference)

코드 작성시 타입이 정해지지 않았어도, 컴파일 타임에 컴파일러가 해당 타입을 유추하는 것

> 타입추론이란 정적 타이핑을 지원하는 언어에서, 타입이 정해지지 않는 변수에 대해서 컴파일러가 변수의 타입을 스스로 찾아낼 수 있도록 하는 기능
>
> - https://m.blog.naver.com/PostView.nhn?blogId=2feelus&logNo=220655685560&proxyReferer=https:%2F%2Fwww.google.com%2F

Java 9 까지는 generics 이나 lamda 식에서 타입추론을 지원

### var

Java 10 이상에서 var 라는 Local Variable Type-Inference 가 추가 됨

- 로컬 변수이어야 함

- 컴파일러가 해당 타입을 유추하기 때문에, 선언과 동시에 값이 할당 되어야 함







